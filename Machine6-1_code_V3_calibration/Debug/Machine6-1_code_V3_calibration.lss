
Machine6-1_code_V3_calibration.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  00000ac4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a50  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001d5f  00800200  00800200  00000ac4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ac4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000af4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000098  00000000  00000000  00000b34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000192e  00000000  00000000  00000bcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e13  00000000  00000000  000024fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c2e  00000000  00000000  0000330d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001ec  00000000  00000000  00003f3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000071e  00000000  00000000  00004128  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000f12  00000000  00000000  00004846  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b8  00000000  00000000  00005758  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
   2:	00 00       	nop
   4:	81 c0       	rjmp	.+258    	; 0x108 <__bad_interrupt>
   6:	00 00       	nop
   8:	7f c0       	rjmp	.+254    	; 0x108 <__bad_interrupt>
   a:	00 00       	nop
   c:	15 c1       	rjmp	.+554    	; 0x238 <__vector_3>
   e:	00 00       	nop
  10:	27 c1       	rjmp	.+590    	; 0x260 <__vector_4>
  12:	00 00       	nop
  14:	79 c0       	rjmp	.+242    	; 0x108 <__bad_interrupt>
  16:	00 00       	nop
  18:	77 c0       	rjmp	.+238    	; 0x108 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	75 c0       	rjmp	.+234    	; 0x108 <__bad_interrupt>
  1e:	00 00       	nop
  20:	73 c0       	rjmp	.+230    	; 0x108 <__bad_interrupt>
  22:	00 00       	nop
  24:	71 c0       	rjmp	.+226    	; 0x108 <__bad_interrupt>
  26:	00 00       	nop
  28:	6f c0       	rjmp	.+222    	; 0x108 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	6d c0       	rjmp	.+218    	; 0x108 <__bad_interrupt>
  2e:	00 00       	nop
  30:	6b c0       	rjmp	.+214    	; 0x108 <__bad_interrupt>
  32:	00 00       	nop
  34:	69 c0       	rjmp	.+210    	; 0x108 <__bad_interrupt>
  36:	00 00       	nop
  38:	67 c0       	rjmp	.+206    	; 0x108 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	65 c0       	rjmp	.+202    	; 0x108 <__bad_interrupt>
  3e:	00 00       	nop
  40:	63 c0       	rjmp	.+198    	; 0x108 <__bad_interrupt>
  42:	00 00       	nop
  44:	61 c0       	rjmp	.+194    	; 0x108 <__bad_interrupt>
  46:	00 00       	nop
  48:	aa c0       	rjmp	.+340    	; 0x19e <__vector_18>
  4a:	00 00       	nop
  4c:	5d c0       	rjmp	.+186    	; 0x108 <__bad_interrupt>
  4e:	00 00       	nop
  50:	5b c0       	rjmp	.+182    	; 0x108 <__bad_interrupt>
  52:	00 00       	nop
  54:	59 c0       	rjmp	.+178    	; 0x108 <__bad_interrupt>
  56:	00 00       	nop
  58:	57 c0       	rjmp	.+174    	; 0x108 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	56 c0       	rjmp	.+172    	; 0x10a <__vector_23>
  5e:	00 00       	nop
  60:	53 c0       	rjmp	.+166    	; 0x108 <__bad_interrupt>
  62:	00 00       	nop
  64:	51 c0       	rjmp	.+162    	; 0x108 <__bad_interrupt>
  66:	00 00       	nop
  68:	4f c0       	rjmp	.+158    	; 0x108 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	4d c0       	rjmp	.+154    	; 0x108 <__bad_interrupt>
  6e:	00 00       	nop
  70:	4b c0       	rjmp	.+150    	; 0x108 <__bad_interrupt>
  72:	00 00       	nop
  74:	49 c0       	rjmp	.+146    	; 0x108 <__bad_interrupt>
  76:	00 00       	nop
  78:	47 c0       	rjmp	.+142    	; 0x108 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	45 c0       	rjmp	.+138    	; 0x108 <__bad_interrupt>
  7e:	00 00       	nop
  80:	43 c0       	rjmp	.+134    	; 0x108 <__bad_interrupt>
  82:	00 00       	nop
  84:	41 c0       	rjmp	.+130    	; 0x108 <__bad_interrupt>
  86:	00 00       	nop
  88:	3f c0       	rjmp	.+126    	; 0x108 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	3d c0       	rjmp	.+122    	; 0x108 <__bad_interrupt>
  8e:	00 00       	nop
  90:	3b c0       	rjmp	.+118    	; 0x108 <__bad_interrupt>
  92:	00 00       	nop
  94:	39 c0       	rjmp	.+114    	; 0x108 <__bad_interrupt>
  96:	00 00       	nop
  98:	37 c0       	rjmp	.+110    	; 0x108 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	35 c0       	rjmp	.+106    	; 0x108 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	33 c0       	rjmp	.+102    	; 0x108 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	31 c0       	rjmp	.+98     	; 0x108 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	2f c0       	rjmp	.+94     	; 0x108 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	2d c0       	rjmp	.+90     	; 0x108 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	2b c0       	rjmp	.+86     	; 0x108 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	29 c0       	rjmp	.+82     	; 0x108 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	27 c0       	rjmp	.+78     	; 0x108 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	25 c0       	rjmp	.+74     	; 0x108 <__bad_interrupt>
  be:	00 00       	nop
  c0:	23 c0       	rjmp	.+70     	; 0x108 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	21 c0       	rjmp	.+66     	; 0x108 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	1f c0       	rjmp	.+62     	; 0x108 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	1d c0       	rjmp	.+58     	; 0x108 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	1b c0       	rjmp	.+54     	; 0x108 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	19 c0       	rjmp	.+50     	; 0x108 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	17 c0       	rjmp	.+46     	; 0x108 <__bad_interrupt>
  da:	00 00       	nop
  dc:	15 c0       	rjmp	.+42     	; 0x108 <__bad_interrupt>
  de:	00 00       	nop
  e0:	13 c0       	rjmp	.+38     	; 0x108 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_clear_bss>:
  f4:	2f e1       	ldi	r18, 0x1F	; 31
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	01 c0       	rjmp	.+2      	; 0xfe <.do_clear_bss_start>

000000fc <.do_clear_bss_loop>:
  fc:	1d 92       	st	X+, r1

000000fe <.do_clear_bss_start>:
  fe:	af 35       	cpi	r26, 0x5F	; 95
 100:	b2 07       	cpc	r27, r18
 102:	e1 f7       	brne	.-8      	; 0xfc <.do_clear_bss_loop>
 104:	52 d2       	rcall	.+1188   	; 0x5aa <main>
 106:	a2 c4       	rjmp	.+2372   	; 0xa4c <_exit>

00000108 <__bad_interrupt>:
 108:	7b cf       	rjmp	.-266    	; 0x0 <__vectors>

0000010a <__vector_23>:


//++++++++++++++++++++++++INTERRUPT SERVICE ROUTINES++++++++++++++++++++++++
//AVR millis() implementation
ISR(TIMER0_OVF_vect)
{
 10a:	1f 92       	push	r1
 10c:	0f 92       	push	r0
 10e:	0f b6       	in	r0, 0x3f	; 63
 110:	0f 92       	push	r0
 112:	11 24       	eor	r1, r1
 114:	0f 93       	push	r16
 116:	1f 93       	push	r17
 118:	2f 93       	push	r18
 11a:	3f 93       	push	r19
 11c:	4f 93       	push	r20
 11e:	5f 93       	push	r21
 120:	6f 93       	push	r22
 122:	7f 93       	push	r23
 124:	8f 93       	push	r24
 126:	9f 93       	push	r25
	unsigned long m = milliseconds;
 128:	00 91 07 02 	lds	r16, 0x0207	; 0x800207 <milliseconds>
 12c:	10 91 08 02 	lds	r17, 0x0208	; 0x800208 <milliseconds+0x1>
 130:	20 91 09 02 	lds	r18, 0x0209	; 0x800209 <milliseconds+0x2>
 134:	30 91 0a 02 	lds	r19, 0x020A	; 0x80020a <milliseconds+0x3>
	//Backup the contents in SREG before performing any math operations
	unsigned char store_sreg = SREG;
 138:	9f b7       	in	r25, 0x3f	; 63
	
	m += MILLIS_INC;
 13a:	b9 01       	movw	r22, r18
 13c:	a8 01       	movw	r20, r16
 13e:	4f 5f       	subi	r20, 0xFF	; 255
 140:	5f 4f       	sbci	r21, 0xFF	; 255
 142:	6f 4f       	sbci	r22, 0xFF	; 255
 144:	7f 4f       	sbci	r23, 0xFF	; 255
	frac_ms += FRAC_INC;
 146:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <frac_ms>
 14a:	8d 5f       	subi	r24, 0xFD	; 253
 14c:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <frac_ms>
	if (frac_ms >= FRAC_MAX)
 150:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <frac_ms>
 154:	8d 37       	cpi	r24, 0x7D	; 125
 156:	58 f0       	brcs	.+22     	; 0x16e <__vector_23+0x64>
	{
		frac_ms -= FRAC_MAX;
 158:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <frac_ms>
 15c:	8d 57       	subi	r24, 0x7D	; 125
 15e:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <frac_ms>
		m++;
 162:	b9 01       	movw	r22, r18
 164:	a8 01       	movw	r20, r16
 166:	4e 5f       	subi	r20, 0xFE	; 254
 168:	5f 4f       	sbci	r21, 0xFF	; 255
 16a:	6f 4f       	sbci	r22, 0xFF	; 255
 16c:	7f 4f       	sbci	r23, 0xFF	; 255
	}
	
	milliseconds = m;
 16e:	40 93 07 02 	sts	0x0207, r20	; 0x800207 <milliseconds>
 172:	50 93 08 02 	sts	0x0208, r21	; 0x800208 <milliseconds+0x1>
 176:	60 93 09 02 	sts	0x0209, r22	; 0x800209 <milliseconds+0x2>
 17a:	70 93 0a 02 	sts	0x020A, r23	; 0x80020a <milliseconds+0x3>
	//Restore backed up version of SREG
	SREG = store_sreg;
 17e:	9f bf       	out	0x3f, r25	; 63
}
 180:	9f 91       	pop	r25
 182:	8f 91       	pop	r24
 184:	7f 91       	pop	r23
 186:	6f 91       	pop	r22
 188:	5f 91       	pop	r21
 18a:	4f 91       	pop	r20
 18c:	3f 91       	pop	r19
 18e:	2f 91       	pop	r18
 190:	1f 91       	pop	r17
 192:	0f 91       	pop	r16
 194:	0f 90       	pop	r0
 196:	0f be       	out	0x3f, r0	; 63
 198:	0f 90       	pop	r0
 19a:	1f 90       	pop	r1
 19c:	18 95       	reti

0000019e <__vector_18>:

//Oddly enough, using ADC_vect as the ISR vector here doesn't work. Instead, using TIMER1_COMPB_vect causes the interrupts to be triggered properly and the ADC values to be recorded into potSamples[]. This implementation works properly
//Table of Interrupt vectors is on pg. 69 ATmega2560 datasheet
ISR(TIMER1_COMPB_vect)
{
 19e:	1f 92       	push	r1
 1a0:	0f 92       	push	r0
 1a2:	0f b6       	in	r0, 0x3f	; 63
 1a4:	0f 92       	push	r0
 1a6:	11 24       	eor	r1, r1
 1a8:	0b b6       	in	r0, 0x3b	; 59
 1aa:	0f 92       	push	r0
 1ac:	2f 93       	push	r18
 1ae:	3f 93       	push	r19
 1b0:	8f 93       	push	r24
 1b2:	9f 93       	push	r25
 1b4:	ef 93       	push	r30
 1b6:	ff 93       	push	r31
 1b8:	cf 93       	push	r28
 1ba:	df 93       	push	r29
 1bc:	1f 92       	push	r1
 1be:	1f 92       	push	r1
 1c0:	cd b7       	in	r28, 0x3d	; 61
 1c2:	de b7       	in	r29, 0x3e	; 62
	//Backup the contents in SREG before performing any math operations
	unsigned char store_sreg = SREG;
 1c4:	2f b7       	in	r18, 0x3f	; 63
	
	//ADCL must be read first, and then ADCH (see the top two paragraphs on pg. 276 ATmega2560 datasheet)
	volatile uint8_t adcl_val = ADCL;
 1c6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
 1ca:	89 83       	std	Y+1, r24	; 0x01
	volatile uint8_t adch_val = ADCH;
 1cc:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
 1d0:	8a 83       	std	Y+2, r24	; 0x02
	
	//Combine the two bytes to form one 10-bit potentiometer sample value, which is then stored in the array of potentiometer samples
	sampVal = ((adch_val << 8) | adcl_val);
 1d2:	8a 81       	ldd	r24, Y+2	; 0x02
 1d4:	90 e0       	ldi	r25, 0x00	; 0
 1d6:	98 2f       	mov	r25, r24
 1d8:	88 27       	eor	r24, r24
 1da:	39 81       	ldd	r19, Y+1	; 0x01
 1dc:	83 2b       	or	r24, r19
 1de:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 1e2:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
	
	potSamples[potSamplesIndex] = sampVal;
 1e6:	e0 91 02 02 	lds	r30, 0x0202	; 0x800202 <potSamplesIndex>
 1ea:	f0 91 03 02 	lds	r31, 0x0203	; 0x800203 <potSamplesIndex+0x1>
 1ee:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 1f2:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 1f6:	ee 0f       	add	r30, r30
 1f8:	ff 1f       	adc	r31, r31
 1fa:	e5 5f       	subi	r30, 0xF5	; 245
 1fc:	fd 4f       	sbci	r31, 0xFD	; 253
 1fe:	91 83       	std	Z+1, r25	; 0x01
 200:	80 83       	st	Z, r24
	potSamplesIndex++;
 202:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <potSamplesIndex>
 206:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <potSamplesIndex+0x1>
 20a:	01 96       	adiw	r24, 0x01	; 1
 20c:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <potSamplesIndex+0x1>
 210:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <potSamplesIndex>
		potSamplesIndex++;
	}
	*/
	
	//Restore backed up version of SREG
	SREG = store_sreg;
 214:	2f bf       	out	0x3f, r18	; 63
}
 216:	0f 90       	pop	r0
 218:	0f 90       	pop	r0
 21a:	df 91       	pop	r29
 21c:	cf 91       	pop	r28
 21e:	ff 91       	pop	r31
 220:	ef 91       	pop	r30
 222:	9f 91       	pop	r25
 224:	8f 91       	pop	r24
 226:	3f 91       	pop	r19
 228:	2f 91       	pop	r18
 22a:	0f 90       	pop	r0
 22c:	0b be       	out	0x3b, r0	; 59
 22e:	0f 90       	pop	r0
 230:	0f be       	out	0x3f, r0	; 63
 232:	0f 90       	pop	r0
 234:	1f 90       	pop	r1
 236:	18 95       	reti

00000238 <__vector_3>:

//Pin 19 on Arduino Mega
//Triggers linear drive to stop moving, which means the panel is at the home position
ISR(INT2_vect)
{
 238:	1f 92       	push	r1
 23a:	0f 92       	push	r0
 23c:	0f b6       	in	r0, 0x3f	; 63
 23e:	0f 92       	push	r0
 240:	11 24       	eor	r1, r1
 242:	8f 93       	push	r24
 244:	9f 93       	push	r25
	flag = 1;
 246:	81 e0       	ldi	r24, 0x01	; 1
 248:	90 e0       	ldi	r25, 0x00	; 0
 24a:	90 93 05 02 	sts	0x0205, r25	; 0x800205 <flag+0x1>
 24e:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <flag>
}
 252:	9f 91       	pop	r25
 254:	8f 91       	pop	r24
 256:	0f 90       	pop	r0
 258:	0f be       	out	0x3f, r0	; 63
 25a:	0f 90       	pop	r0
 25c:	1f 90       	pop	r1
 25e:	18 95       	reti

00000260 <__vector_4>:

//Pin 18 on Arduino Mega
//CONTINUE Button
ISR(INT3_vect)
{
 260:	1f 92       	push	r1
 262:	0f 92       	push	r0
 264:	0f b6       	in	r0, 0x3f	; 63
 266:	0f 92       	push	r0
 268:	11 24       	eor	r1, r1
 26a:	2f 93       	push	r18
 26c:	8f 93       	push	r24
 26e:	9f 93       	push	r25
	flag = 2;
 270:	82 e0       	ldi	r24, 0x02	; 2
 272:	90 e0       	ldi	r25, 0x00	; 0
 274:	90 93 05 02 	sts	0x0205, r25	; 0x800205 <flag+0x1>
 278:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <flag>
	PORTB |= (1<<PB0);
 27c:	85 b1       	in	r24, 0x05	; 5
 27e:	81 60       	ori	r24, 0x01	; 1
 280:	85 b9       	out	0x05, r24	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 282:	2f ef       	ldi	r18, 0xFF	; 255
 284:	86 e7       	ldi	r24, 0x76	; 118
 286:	91 e0       	ldi	r25, 0x01	; 1
 288:	21 50       	subi	r18, 0x01	; 1
 28a:	80 40       	sbci	r24, 0x00	; 0
 28c:	90 40       	sbci	r25, 0x00	; 0
 28e:	e1 f7       	brne	.-8      	; 0x288 <__vector_4+0x28>
 290:	00 c0       	rjmp	.+0      	; 0x292 <__vector_4+0x32>
 292:	00 00       	nop
	_delay_ms(30);
	PORTB &= (0<<PB0);
 294:	85 b1       	in	r24, 0x05	; 5
 296:	15 b8       	out	0x05, r1	; 5
 298:	2f ef       	ldi	r18, 0xFF	; 255
 29a:	86 e7       	ldi	r24, 0x76	; 118
 29c:	91 e0       	ldi	r25, 0x01	; 1
 29e:	21 50       	subi	r18, 0x01	; 1
 2a0:	80 40       	sbci	r24, 0x00	; 0
 2a2:	90 40       	sbci	r25, 0x00	; 0
 2a4:	e1 f7       	brne	.-8      	; 0x29e <__vector_4+0x3e>
 2a6:	00 c0       	rjmp	.+0      	; 0x2a8 <__vector_4+0x48>
 2a8:	00 00       	nop
	_delay_ms(30);
}
 2aa:	9f 91       	pop	r25
 2ac:	8f 91       	pop	r24
 2ae:	2f 91       	pop	r18
 2b0:	0f 90       	pop	r0
 2b2:	0f be       	out	0x3f, r0	; 63
 2b4:	0f 90       	pop	r0
 2b6:	1f 90       	pop	r1
 2b8:	18 95       	reti

000002ba <initTimer0>:
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void initTimer0()
{
	//Sets Timer/Counter0 to Fast PWM mode
	TCCR0A = (1<<WGM01) | (1<<WGM00);
 2ba:	83 e0       	ldi	r24, 0x03	; 3
 2bc:	84 bd       	out	0x24, r24	; 36
	
	//Sets the clock prescaler to divide by 64 (clk(T0S) / 64), page 131 of ATMega 2560 datasheet (clk(T0S) is the same as the system clock, which is 16MHz)
	TCCR0B = (1<<CS01) | (1<<CS00);
 2be:	85 bd       	out	0x25, r24	; 37
	
	//Enable TimerCounter0 Overflow interrupt
	TIMSK0 |= (1<<TOIE0);
 2c0:	ee e6       	ldi	r30, 0x6E	; 110
 2c2:	f0 e0       	ldi	r31, 0x00	; 0
 2c4:	80 81       	ld	r24, Z
 2c6:	81 60       	ori	r24, 0x01	; 1
 2c8:	80 83       	st	Z, r24
	
	sei();
 2ca:	78 94       	sei
 2cc:	08 95       	ret

000002ce <clearTimer0>:
}

void clearTimer0()
{
	cli();
 2ce:	f8 94       	cli
	
	TCCR0A = 0;
 2d0:	14 bc       	out	0x24, r1	; 36
	TCCR0B = 0;
 2d2:	15 bc       	out	0x25, r1	; 37
	TIMSK0 = 0;
 2d4:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <__TEXT_REGION_LENGTH__+0x7c006e>
 2d8:	08 95       	ret

000002da <millis>:
}

//AVR millis() implementation, except milliseconds is set back to 0 before returning m
unsigned long millis()
{
 2da:	cf 93       	push	r28
	unsigned long m;
	unsigned char oldSREG = SREG;
 2dc:	cf b7       	in	r28, 0x3f	; 63
	
	clearTimer0();
 2de:	f7 df       	rcall	.-18     	; 0x2ce <clearTimer0>
	
	m = milliseconds;
 2e0:	60 91 07 02 	lds	r22, 0x0207	; 0x800207 <milliseconds>
 2e4:	70 91 08 02 	lds	r23, 0x0208	; 0x800208 <milliseconds+0x1>
 2e8:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <milliseconds+0x2>
 2ec:	90 91 0a 02 	lds	r25, 0x020A	; 0x80020a <milliseconds+0x3>
	SREG = oldSREG;
 2f0:	cf bf       	out	0x3f, r28	; 63
	
	//Resets the millisecond counter, after calling millis() you will need to call initTimer0() again
	milliseconds = 0;
 2f2:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <milliseconds>
 2f6:	10 92 08 02 	sts	0x0208, r1	; 0x800208 <milliseconds+0x1>
 2fa:	10 92 09 02 	sts	0x0209, r1	; 0x800209 <milliseconds+0x2>
 2fe:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <milliseconds+0x3>
	frac_ms = 0;
 302:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <frac_ms>
	
	return m;
}
 306:	cf 91       	pop	r28
 308:	08 95       	ret

0000030a <initADC>:

void initADC()
{
	//Sets voltage reference by connecting AVCC with external capacitor at AREF pin (pg. 287 Table 125 ATmega2560 datasheet)
	ADMUX |= (1<<REFS0);
 30a:	ec e7       	ldi	r30, 0x7C	; 124
 30c:	f0 e0       	ldi	r31, 0x00	; 0
 30e:	80 81       	ld	r24, Z
 310:	80 64       	ori	r24, 0x40	; 64
 312:	80 83       	st	Z, r24
	
	//To select between 8-bit and 10-bit precision of the ADC, see page 292 of ATmega2560 datasheet for "The ADC Data Register - ADCL and ADCH"
	//By default I want 10-bit precision so therefore I will leave the ADLAR bit of ADMUX cleared (set to 0).
	
	//Disable the digital input buffer that shares a pin with ADC0 to save power (see pg. 293 ATmega2560 datasheet)
	DIDR0 |= (1<<ADC0D);
 314:	ee e7       	ldi	r30, 0x7E	; 126
 316:	f0 e0       	ldi	r31, 0x00	; 0
 318:	80 81       	ld	r24, Z
 31a:	81 60       	ori	r24, 0x01	; 1
 31c:	80 83       	st	Z, r24
	
	//Enable ADC, Enable Auto trigger, Set clock prescaler to 128 (for all of these, see pg 291 ATmega2560 datasheet)
	//I set the ADC clock prescaler to 128 so that the ADC conversion frequency is 125kHz, which is in the acceptable range of ADC clock frequencies (50kHz-200kHz)
	ADCSRA = (1<<ADEN) | (1<<ADATE) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
 31e:	ea e7       	ldi	r30, 0x7A	; 122
 320:	f0 e0       	ldi	r31, 0x00	; 0
 322:	87 ea       	ldi	r24, 0xA7	; 167
 324:	80 83       	st	Z, r24
	//Set ADC Auto Trigger Source to Timer/Counter1 Compare Match B
	ADCSRB = (1<<ADTS2) | (1<<ADTS0);
 326:	85 e0       	ldi	r24, 0x05	; 5
 328:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <__TEXT_REGION_LENGTH__+0x7c007b>
	
	//++++++++++++++++++++++++++
	//Timer1 Setup
	
	//Sets Timer/Counter1 to Fast PWM mode with CTC (see pg. 157 & 160 ATmega2560 datasheet)
	TCCR1A = (1<<WGM11) | (1<<WGM10);
 32c:	93 e0       	ldi	r25, 0x03	; 3
 32e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x7c0080>
	TCCR1B = (1<<WGM13) | (1<<WGM12);
 332:	a1 e8       	ldi	r26, 0x81	; 129
 334:	b0 e0       	ldi	r27, 0x00	; 0
 336:	98 e1       	ldi	r25, 0x18	; 24
 338:	9c 93       	st	X, r25
	//Sets the clock prescaler to divide by 1024 (clk(T1S) / 1024), page 162 of ATMega 2560 datasheet (clk(T1S) is the same as the system clock, which is 16MHz)
	TCCR1B = (1<<CS12) | (1<<CS10);
 33a:	8c 93       	st	X, r24
	
	//OCR1A value calculated using formula on pg 150 ATmega2560 datasheet for f(OCnxPWM), we require f(OCnxPWM) to be 61 Hz to take a sample every 16ms
	//I calculated the value of OCR1B to be 255 originally, but after testing it, the sampling frequency turned out to be 15Hz.
	OCR1B = 255; //64
 33c:	8f ef       	ldi	r24, 0xFF	; 255
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7c008b>
 344:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7c008a>
	TCNT1H = 0;
 348:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7c0085>
	
	TIFR1 |= (1<<OCF1B);
 34c:	86 b3       	in	r24, 0x16	; 22
 34e:	84 60       	ori	r24, 0x04	; 4
 350:	86 bb       	out	0x16, r24	; 22
	TIMSK1 |= (1<<OCIE1B);
 352:	af e6       	ldi	r26, 0x6F	; 111
 354:	b0 e0       	ldi	r27, 0x00	; 0
 356:	8c 91       	ld	r24, X
 358:	84 60       	ori	r24, 0x04	; 4
 35a:	8c 93       	st	X, r24
	//++++++++++++++++++++++++++
	
	sei();
 35c:	78 94       	sei
	
	//Start the first conversion
	ADCSRA |= (1<<ADSC);
 35e:	80 81       	ld	r24, Z
 360:	80 64       	ori	r24, 0x40	; 64
 362:	80 83       	st	Z, r24
 364:	08 95       	ret

00000366 <stopADC>:
}

void stopADC()
{
	cli();
 366:	f8 94       	cli
	
	TCCR1A = 0;
 368:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7c0080>
	TCCR1B = 0;
 36c:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x7c0081>
	TIFR1 = 0;
 370:	16 ba       	out	0x16, r1	; 22
	TIMSK1 = 0;
 372:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7c006f>
	
	ADCSRA = 0;
 376:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__TEXT_REGION_LENGTH__+0x7c007a>
	ADCSRB = 0;
 37a:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7c007b>
 37e:	08 95       	ret

00000380 <greenBlink>:
}

void greenBlink(int num)
{
 380:	ac 01       	movw	r20, r24
	for (int i = 0; i < num; i++)
 382:	20 e0       	ldi	r18, 0x00	; 0
 384:	30 e0       	ldi	r19, 0x00	; 0
 386:	19 c0       	rjmp	.+50     	; 0x3ba <greenBlink+0x3a>
	{
		PORTB |= (1<<PB0);
 388:	95 b1       	in	r25, 0x05	; 5
 38a:	91 60       	ori	r25, 0x01	; 1
 38c:	95 b9       	out	0x05, r25	; 5
 38e:	6f ef       	ldi	r22, 0xFF	; 255
 390:	87 e8       	ldi	r24, 0x87	; 135
 392:	93 e1       	ldi	r25, 0x13	; 19
 394:	61 50       	subi	r22, 0x01	; 1
 396:	80 40       	sbci	r24, 0x00	; 0
 398:	90 40       	sbci	r25, 0x00	; 0
 39a:	e1 f7       	brne	.-8      	; 0x394 <greenBlink+0x14>
 39c:	00 c0       	rjmp	.+0      	; 0x39e <greenBlink+0x1e>
 39e:	00 00       	nop
		_delay_ms(400);
		PORTB &= (0<<PB0);
 3a0:	85 b1       	in	r24, 0x05	; 5
 3a2:	15 b8       	out	0x05, r1	; 5
 3a4:	6f ef       	ldi	r22, 0xFF	; 255
 3a6:	87 e8       	ldi	r24, 0x87	; 135
 3a8:	93 e1       	ldi	r25, 0x13	; 19
 3aa:	61 50       	subi	r22, 0x01	; 1
 3ac:	80 40       	sbci	r24, 0x00	; 0
 3ae:	90 40       	sbci	r25, 0x00	; 0
 3b0:	e1 f7       	brne	.-8      	; 0x3aa <greenBlink+0x2a>
 3b2:	00 c0       	rjmp	.+0      	; 0x3b4 <greenBlink+0x34>
 3b4:	00 00       	nop
	ADCSRB = 0;
}

void greenBlink(int num)
{
	for (int i = 0; i < num; i++)
 3b6:	2f 5f       	subi	r18, 0xFF	; 255
 3b8:	3f 4f       	sbci	r19, 0xFF	; 255
 3ba:	24 17       	cp	r18, r20
 3bc:	35 07       	cpc	r19, r21
 3be:	24 f3       	brlt	.-56     	; 0x388 <greenBlink+0x8>
		PORTB |= (1<<PB0);
		_delay_ms(400);
		PORTB &= (0<<PB0);
		_delay_ms(400);
	}
}
 3c0:	08 95       	ret

000003c2 <redBlink>:

void redBlink()
{
	PORTB |= (1<<PB5);
 3c2:	85 b1       	in	r24, 0x05	; 5
 3c4:	80 62       	ori	r24, 0x20	; 32
 3c6:	85 b9       	out	0x05, r24	; 5
 3c8:	2f ef       	ldi	r18, 0xFF	; 255
 3ca:	8d e2       	ldi	r24, 0x2D	; 45
 3cc:	92 e2       	ldi	r25, 0x22	; 34
 3ce:	21 50       	subi	r18, 0x01	; 1
 3d0:	80 40       	sbci	r24, 0x00	; 0
 3d2:	90 40       	sbci	r25, 0x00	; 0
 3d4:	e1 f7       	brne	.-8      	; 0x3ce <redBlink+0xc>
 3d6:	00 c0       	rjmp	.+0      	; 0x3d8 <redBlink+0x16>
 3d8:	00 00       	nop
	_delay_ms(700);
	PORTB &= (0<<PB5);
 3da:	85 b1       	in	r24, 0x05	; 5
 3dc:	15 b8       	out	0x05, r1	; 5
 3de:	2f ef       	ldi	r18, 0xFF	; 255
 3e0:	8d e2       	ldi	r24, 0x2D	; 45
 3e2:	92 e2       	ldi	r25, 0x22	; 34
 3e4:	21 50       	subi	r18, 0x01	; 1
 3e6:	80 40       	sbci	r24, 0x00	; 0
 3e8:	90 40       	sbci	r25, 0x00	; 0
 3ea:	e1 f7       	brne	.-8      	; 0x3e4 <redBlink+0x22>
 3ec:	00 c0       	rjmp	.+0      	; 0x3ee <redBlink+0x2c>
 3ee:	00 00       	nop
 3f0:	08 95       	ret

000003f2 <displayNum>:
	_delay_ms(700);
}

//When flag == 0, this method will be used to print out time. When flag == 1, this method will be used to print out a formatted potentiometer sample
void  displayNum(unsigned long val, uint8_t flag)
{
 3f2:	ef 92       	push	r14
 3f4:	ff 92       	push	r15
 3f6:	1f 93       	push	r17
 3f8:	cf 93       	push	r28
 3fa:	df 93       	push	r29
 3fc:	00 d0       	rcall	.+0      	; 0x3fe <displayNum+0xc>
 3fe:	00 d0       	rcall	.+0      	; 0x400 <__LOCK_REGION_LENGTH__>
 400:	cd b7       	in	r28, 0x3d	; 61
 402:	de b7       	in	r29, 0x3e	; 62
 404:	dc 01       	movw	r26, r24
 406:	cb 01       	movw	r24, r22
 408:	f4 2e       	mov	r15, r20
	//The first character extracted from m should be the last character printed on the screen, otherwise it will print the recorded time backwards and it will make me think the error is something else
	//Since character_stack is 6 elements long which means it can hold 6 characters used to represent a time up to as large as 16 minutes
	uint8_t index = 0;
 40a:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t character_stack[6];
	
	uint8_t val_temp;
	while (val > 0)
 40c:	11 c0       	rjmp	.+34     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
	{
		val_temp = val % 10;
		val /= 10;
 40e:	bc 01       	movw	r22, r24
 410:	cd 01       	movw	r24, r26
 412:	2a e0       	ldi	r18, 0x0A	; 10
 414:	30 e0       	ldi	r19, 0x00	; 0
 416:	40 e0       	ldi	r20, 0x00	; 0
 418:	50 e0       	ldi	r21, 0x00	; 0
 41a:	f6 d2       	rcall	.+1516   	; 0xa08 <__udivmodsi4>
 41c:	da 01       	movw	r26, r20
 41e:	c9 01       	movw	r24, r18
		character_stack[index] = val_temp;
 420:	e1 e0       	ldi	r30, 0x01	; 1
 422:	f0 e0       	ldi	r31, 0x00	; 0
 424:	ec 0f       	add	r30, r28
 426:	fd 1f       	adc	r31, r29
 428:	e1 0f       	add	r30, r17
 42a:	f1 1d       	adc	r31, r1
 42c:	60 83       	st	Z, r22
		index++;
 42e:	1f 5f       	subi	r17, 0xFF	; 255
	//Since character_stack is 6 elements long which means it can hold 6 characters used to represent a time up to as large as 16 minutes
	uint8_t index = 0;
	uint8_t character_stack[6];
	
	uint8_t val_temp;
	while (val > 0)
 430:	00 97       	sbiw	r24, 0x00	; 0
 432:	a1 05       	cpc	r26, r1
 434:	b1 05       	cpc	r27, r1
 436:	59 f7       	brne	.-42     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
 438:	20 e0       	ldi	r18, 0x00	; 0
 43a:	30 e0       	ldi	r19, 0x00	; 0
 43c:	1b c0       	rjmp	.+54     	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
		index++;
	}
	
	for (int i = 0; i < 3; i++)
	{
		PORTL |= (1<<PL0);
 43e:	eb e0       	ldi	r30, 0x0B	; 11
 440:	f1 e0       	ldi	r31, 0x01	; 1
 442:	80 81       	ld	r24, Z
 444:	81 60       	ori	r24, 0x01	; 1
 446:	80 83       	st	Z, r24
 448:	4f ef       	ldi	r20, 0xFF	; 255
 44a:	85 ea       	ldi	r24, 0xA5	; 165
 44c:	9e e0       	ldi	r25, 0x0E	; 14
 44e:	41 50       	subi	r20, 0x01	; 1
 450:	80 40       	sbci	r24, 0x00	; 0
 452:	90 40       	sbci	r25, 0x00	; 0
 454:	e1 f7       	brne	.-8      	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
 456:	00 c0       	rjmp	.+0      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
 458:	00 00       	nop
		_delay_ms(300);
		PORTL &= (0<<PL0);
 45a:	80 81       	ld	r24, Z
 45c:	10 82       	st	Z, r1
 45e:	4f ef       	ldi	r20, 0xFF	; 255
 460:	85 ea       	ldi	r24, 0xA5	; 165
 462:	9e e0       	ldi	r25, 0x0E	; 14
 464:	41 50       	subi	r20, 0x01	; 1
 466:	80 40       	sbci	r24, 0x00	; 0
 468:	90 40       	sbci	r25, 0x00	; 0
 46a:	e1 f7       	brne	.-8      	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
 46c:	00 c0       	rjmp	.+0      	; 0x46e <__LOCK_REGION_LENGTH__+0x6e>
 46e:	00 00       	nop
		val /= 10;
		character_stack[index] = val_temp;
		index++;
	}
	
	for (int i = 0; i < 3; i++)
 470:	2f 5f       	subi	r18, 0xFF	; 255
 472:	3f 4f       	sbci	r19, 0xFF	; 255
 474:	23 30       	cpi	r18, 0x03	; 3
 476:	31 05       	cpc	r19, r1
 478:	14 f3       	brlt	.-60     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
		PORTL &= (0<<PL0);
		_delay_ms(300);
	}
	
	//If printing out a potentiometer sample, turn on indicator LED to indicate that it is displaying Pot Samples
	if (flag)
 47a:	ff 20       	and	r15, r15
 47c:	29 f0       	breq	.+10     	; 0x488 <__LOCK_REGION_LENGTH__+0x88>
	{
		PORTL |= (1<<PL0);
 47e:	eb e0       	ldi	r30, 0x0B	; 11
 480:	f1 e0       	ldi	r31, 0x01	; 1
 482:	80 81       	ld	r24, Z
 484:	81 60       	ori	r24, 0x01	; 1
 486:	80 83       	st	Z, r24
 488:	e1 2c       	mov	r14, r1
 48a:	f1 2c       	mov	r15, r1
 48c:	0d c0       	rjmp	.+26     	; 0x4a8 <__LOCK_REGION_LENGTH__+0xa8>
	}
	
	//Prints out the number starting from the least significant digit
	for (int i = 0; i < index; i++)//for (int i = (index - 1); i >= 0; i--)
	{
		greenBlink(character_stack[i]);
 48e:	e1 e0       	ldi	r30, 0x01	; 1
 490:	f0 e0       	ldi	r31, 0x00	; 0
 492:	ec 0f       	add	r30, r28
 494:	fd 1f       	adc	r31, r29
 496:	ee 0d       	add	r30, r14
 498:	ff 1d       	adc	r31, r15
 49a:	80 81       	ld	r24, Z
 49c:	90 e0       	ldi	r25, 0x00	; 0
		redBlink();
 49e:	70 df       	rcall	.-288    	; 0x380 <greenBlink>
 4a0:	90 df       	rcall	.-224    	; 0x3c2 <redBlink>
	{
		PORTL |= (1<<PL0);
	}
	
	//Prints out the number starting from the least significant digit
	for (int i = 0; i < index; i++)//for (int i = (index - 1); i >= 0; i--)
 4a2:	4f ef       	ldi	r20, 0xFF	; 255
 4a4:	e4 1a       	sub	r14, r20
 4a6:	f4 0a       	sbc	r15, r20
 4a8:	81 2f       	mov	r24, r17
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	e8 16       	cp	r14, r24
 4ae:	f9 06       	cpc	r15, r25
 4b0:	74 f3       	brlt	.-36     	; 0x48e <__LOCK_REGION_LENGTH__+0x8e>
	{
		greenBlink(character_stack[i]);
		redBlink();
	}
}
 4b2:	26 96       	adiw	r28, 0x06	; 6
 4b4:	0f b6       	in	r0, 0x3f	; 63
 4b6:	f8 94       	cli
 4b8:	de bf       	out	0x3e, r29	; 62
 4ba:	0f be       	out	0x3f, r0	; 63
 4bc:	cd bf       	out	0x3d, r28	; 61
 4be:	df 91       	pop	r29
 4c0:	cf 91       	pop	r28
 4c2:	1f 91       	pop	r17
 4c4:	ff 90       	pop	r15
 4c6:	ef 90       	pop	r14
 4c8:	08 95       	ret

000004ca <displayPotSamples>:

void displayPotSamples()
{
 4ca:	cf 93       	push	r28
 4cc:	df 93       	push	r29
	//Clear interrupts so that potentiometer samples don't keep getting taken and cause potSamplesIndex to increase, causing the program to get stuck in an infinite loop during the for loop below
	cli();
 4ce:	f8 94       	cli
	
	//displayNum(potSamplesIndex, 0);
	//_delay_ms(1500);
	
	//If there are no samples recorded, then blink both LEDs (this means that something isn't working properly, there should always be samples recorded even if the program is running for only a few ms
	if (!potSamplesIndex)
 4d0:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <potSamplesIndex>
 4d4:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <potSamplesIndex+0x1>
 4d8:	89 2b       	or	r24, r25
 4da:	19 f5       	brne	.+70     	; 0x522 <displayPotSamples+0x58>
	{
		while (1)
		{
			PORTB = (1<<PB0) | (1<<PB5);
 4dc:	81 e2       	ldi	r24, 0x21	; 33
 4de:	85 b9       	out	0x05, r24	; 5
 4e0:	2f ef       	ldi	r18, 0xFF	; 255
 4e2:	89 e6       	ldi	r24, 0x69	; 105
 4e4:	98 e1       	ldi	r25, 0x18	; 24
 4e6:	21 50       	subi	r18, 0x01	; 1
 4e8:	80 40       	sbci	r24, 0x00	; 0
 4ea:	90 40       	sbci	r25, 0x00	; 0
 4ec:	e1 f7       	brne	.-8      	; 0x4e6 <displayPotSamples+0x1c>
 4ee:	00 c0       	rjmp	.+0      	; 0x4f0 <displayPotSamples+0x26>
 4f0:	00 00       	nop
			_delay_ms(500);
			PORTB = (0<<PB0) & (0<<PB5);
 4f2:	15 b8       	out	0x05, r1	; 5
 4f4:	2f ef       	ldi	r18, 0xFF	; 255
 4f6:	89 e6       	ldi	r24, 0x69	; 105
 4f8:	98 e1       	ldi	r25, 0x18	; 24
 4fa:	21 50       	subi	r18, 0x01	; 1
 4fc:	80 40       	sbci	r24, 0x00	; 0
 4fe:	90 40       	sbci	r25, 0x00	; 0
 500:	e1 f7       	brne	.-8      	; 0x4fa <displayPotSamples+0x30>
 502:	00 c0       	rjmp	.+0      	; 0x504 <displayPotSamples+0x3a>
 504:	00 00       	nop
 506:	ea cf       	rjmp	.-44     	; 0x4dc <displayPotSamples+0x12>
		}
	}
	
	for (uint16_t i = 0; i < potSamplesIndex; i++)
	{
		displayNum(potSamples[i], 1);
 508:	fe 01       	movw	r30, r28
 50a:	ee 0f       	add	r30, r30
 50c:	ff 1f       	adc	r31, r31
 50e:	e5 5f       	subi	r30, 0xF5	; 245
 510:	fd 4f       	sbci	r31, 0xFD	; 253
 512:	60 81       	ld	r22, Z
 514:	71 81       	ldd	r23, Z+1	; 0x01
 516:	80 e0       	ldi	r24, 0x00	; 0
 518:	90 e0       	ldi	r25, 0x00	; 0
 51a:	41 e0       	ldi	r20, 0x01	; 1
 51c:	6a df       	rcall	.-300    	; 0x3f2 <displayNum>
			PORTB = (0<<PB0) & (0<<PB5);
			_delay_ms(500);
		}
	}
	
	for (uint16_t i = 0; i < potSamplesIndex; i++)
 51e:	21 96       	adiw	r28, 0x01	; 1
 520:	02 c0       	rjmp	.+4      	; 0x526 <displayPotSamples+0x5c>
 522:	c0 e0       	ldi	r28, 0x00	; 0
 524:	d0 e0       	ldi	r29, 0x00	; 0
 526:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <potSamplesIndex>
 52a:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <potSamplesIndex+0x1>
 52e:	c8 17       	cp	r28, r24
 530:	d9 07       	cpc	r29, r25
 532:	50 f3       	brcs	.-44     	; 0x508 <displayPotSamples+0x3e>
	{
		displayNum(potSamples[i], 1);
	}
}
 534:	df 91       	pop	r29
 536:	cf 91       	pop	r28
 538:	08 95       	ret

0000053a <displayTime>:

//Converts time in milliseconds into character bitmaps which are written to the GDDRAM to be displayed on the OLED screen
void displayTime(unsigned long m)
{
	displayNum(m, 0);
 53a:	40 e0       	ldi	r20, 0x00	; 0
 53c:	5a cf       	rjmp	.-332    	; 0x3f2 <displayNum>
 53e:	08 95       	ret

00000540 <analogWriteV2>:
/*
(16 * 10^6) * (1/1024) * (7/256) = 427.2460938 Hz
*/
void analogWriteV2(int val)
{
	DDRH = (1<<DDH5) | (1<<DDH6);
 540:	20 e6       	ldi	r18, 0x60	; 96
 542:	20 93 01 01 	sts	0x0101, r18	; 0x800101 <__TEXT_REGION_LENGTH__+0x7c0101>
	
	if (val == 0)
 546:	00 97       	sbiw	r24, 0x00	; 0
 548:	51 f4       	brne	.+20     	; 0x55e <analogWriteV2+0x1e>
	{
		TCCR2A &= (0<<COM2B1);
 54a:	e0 eb       	ldi	r30, 0xB0	; 176
 54c:	f0 e0       	ldi	r31, 0x00	; 0
 54e:	20 81       	ld	r18, Z
 550:	10 82       	st	Z, r1
		TCCR4A &= (0<<COM4C1);
 552:	e0 ea       	ldi	r30, 0xA0	; 160
 554:	f0 e0       	ldi	r31, 0x00	; 0
 556:	20 81       	ld	r18, Z
 558:	10 82       	st	Z, r1
		PORTH = (0<<PH5) & (0<<PH6);
 55a:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <__TEXT_REGION_LENGTH__+0x7c0102>
	}
	if (val == 255)
 55e:	8f 3f       	cpi	r24, 0xFF	; 255
 560:	91 05       	cpc	r25, r1
 562:	21 f4       	brne	.+8      	; 0x56c <analogWriteV2+0x2c>
	{
		PORTH = (1<<PH5) | (1<<PH6);
 564:	80 e6       	ldi	r24, 0x60	; 96
 566:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x7c0102>
 56a:	08 95       	ret
	}
	else
	{
		TCCR2A |= (1<<WGM20);
 56c:	e0 eb       	ldi	r30, 0xB0	; 176
 56e:	f0 e0       	ldi	r31, 0x00	; 0
 570:	20 81       	ld	r18, Z
 572:	21 60       	ori	r18, 0x01	; 1
 574:	20 83       	st	Z, r18
		TCCR2A |= (1<<COM2B1);
 576:	20 81       	ld	r18, Z
 578:	20 62       	ori	r18, 0x20	; 32
 57a:	20 83       	st	Z, r18
		
		TCCR4A |= (1<<WGM40);
 57c:	e0 ea       	ldi	r30, 0xA0	; 160
 57e:	f0 e0       	ldi	r31, 0x00	; 0
 580:	20 81       	ld	r18, Z
 582:	21 60       	ori	r18, 0x01	; 1
 584:	20 83       	st	Z, r18
		TCCR4A |= (1<<COM4C1);
 586:	20 81       	ld	r18, Z
 588:	28 60       	ori	r18, 0x08	; 8
 58a:	20 83       	st	Z, r18
		
		//Sets the clock prescaler to divide by 1024 (clk(T2S) / 1024), page 188 of ATMega 2560 datasheet
		//TCCR2B = (1<<CS20) | (1<<CS21) | (1<<CS22);
		
		//Sets the clock prescaler to divide by 256 (clk(T2S) / 256), page 188 of ATMega 2560 datasheet
		TCCR2B = (1<<CS22) | (1<<CS21);
 58c:	26 e0       	ldi	r18, 0x06	; 6
 58e:	20 93 b1 00 	sts	0x00B1, r18	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7c00b1>
		//Sets the clock prescaler to divide by 256 (clk(T4S) / 256), page 162 of ATMega 2560 datasheet
		TCCR4B |= (1<<CS42);
 592:	e1 ea       	ldi	r30, 0xA1	; 161
 594:	f0 e0       	ldi	r31, 0x00	; 0
 596:	20 81       	ld	r18, Z
 598:	24 60       	ori	r18, 0x04	; 4
 59a:	20 83       	st	Z, r18
		//TCCR2B = (1<<CS20) | (1<<CS21);
		
		//Sets the clock prescaler to divide by 8 (clk(T2S) / 8), page 188 of ATMega 2560 datasheet
		//TCCR2B |= (1<<CS21);
		
		OCR2B = val;
 59c:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7c00b4>
		OCR4C = val;
 5a0:	90 93 ad 00 	sts	0x00AD, r25	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7c00ad>
 5a4:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7c00ac>
 5a8:	08 95       	ret

000005aa <main>:
	}
}

int main(void)
{
	cli();
 5aa:	f8 94       	cli
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Machine Setup
	
	//Set Pin 10 to output mode
	//Pin 10 Arduino Mega is STEP pin for the Linear Drive Motor
	DDRB |= (1<<DDB4);
 5ac:	84 b1       	in	r24, 0x04	; 4
 5ae:	80 61       	ori	r24, 0x10	; 16
 5b0:	84 b9       	out	0x04, r24	; 4
	
	//Pin 9 Arduino Mega is STEP pin for a Panel Motor
	DDRH |= (1<<DDH6);
 5b2:	e1 e0       	ldi	r30, 0x01	; 1
 5b4:	f1 e0       	ldi	r31, 0x01	; 1
 5b6:	80 81       	ld	r24, Z
 5b8:	80 64       	ori	r24, 0x40	; 64
 5ba:	80 83       	st	Z, r24
	
	//Pin 8 Arduino Mega is STEP pin for a Panel Motor
	DDRH |= (1<<DDH5);
 5bc:	80 81       	ld	r24, Z
 5be:	80 62       	ori	r24, 0x20	; 32
 5c0:	80 83       	st	Z, r24
	
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
	//Pin 5 Arduino Mega is DIR pin for the Linear Drive Motor
	DDRE |= (1<<DDE3);
 5c2:	8d b1       	in	r24, 0x0d	; 13
 5c4:	88 60       	ori	r24, 0x08	; 8
 5c6:	8d b9       	out	0x0d, r24	; 13
	
	//Pin 4 Arduino Mega is DIR pin for a Panel Motor
	DDRG |= (1<<DDG5);
 5c8:	83 b3       	in	r24, 0x13	; 19
 5ca:	80 62       	ori	r24, 0x20	; 32
 5cc:	83 bb       	out	0x13, r24	; 19
	
	//Pin 14 Arduino Mega is DIR pin for a Panel Motor
	DDRJ |= (1<<DDJ1);
 5ce:	e4 e0       	ldi	r30, 0x04	; 4
 5d0:	f1 e0       	ldi	r31, 0x01	; 1
 5d2:	80 81       	ld	r24, Z
 5d4:	82 60       	ori	r24, 0x02	; 2
 5d6:	80 83       	st	Z, r24
	PINS 6, 16 AND 17 ON THE ARDUINO MEGA ARE BROKEN AND DO NOT WORK, THEY STAY LOW CONSTANTLY FOR SOME REASON I DON'T KNOW WHY so use different pins instead
	*/
	//-------------------------------------------------------------------------------------------------------
	//Clockwise rotation moves panel forward & Counterclockwise rotation moves panel backwards
	//When DIR is high, linear drive motor rotates clockwise and moves panel forward
	PORTE |= (1<<PE3);
 5d8:	8e b1       	in	r24, 0x0e	; 14
 5da:	88 60       	ori	r24, 0x08	; 8
 5dc:	8e b9       	out	0x0e, r24	; 14
	//Keep Panel direction pins HIGH because that direction has less gear slipping
	PORTG |= (1<<PG5);
 5de:	84 b3       	in	r24, 0x14	; 20
 5e0:	80 62       	ori	r24, 0x20	; 32
 5e2:	84 bb       	out	0x14, r24	; 20
	PORTJ |= (1<<PJ1);
 5e4:	e5 e0       	ldi	r30, 0x05	; 5
 5e6:	f1 e0       	ldi	r31, 0x01	; 1
 5e8:	80 81       	ld	r24, Z
 5ea:	82 60       	ori	r24, 0x02	; 2
 5ec:	80 83       	st	Z, r24
	//-------------------------------------------------------------------------------------------------------
	//Make sure INT2/INT3/INT5 pins is in input mode with the internal pullup resistors enabled
	DDRD = (0<<DDD3) & (0<<DDD2);
 5ee:	1a b8       	out	0x0a, r1	; 10
	PORTD = (1<<PD3) | (1<<PD2);
 5f0:	8c e0       	ldi	r24, 0x0C	; 12
 5f2:	8b b9       	out	0x0b, r24	; 11
	
	//DDRE &= (0<<DDE5);
	//PORTE |= (1<<PE5);
	
	MCUCR &= (0<<PUD);
 5f4:	85 b7       	in	r24, 0x35	; 53
 5f6:	15 be       	out	0x35, r1	; 53
	//-------------------------------------------------------------------------------------------------------
	
	//Beginning sample display indicator
	DDRL |= (1<<DDL0);
 5f8:	ea e0       	ldi	r30, 0x0A	; 10
 5fa:	f1 e0       	ldi	r31, 0x01	; 1
 5fc:	80 81       	ld	r24, Z
 5fe:	81 60       	ori	r24, 0x01	; 1
 600:	80 83       	st	Z, r24
	PORTL &= (0<<PL0);
 602:	eb e0       	ldi	r30, 0x0B	; 11
 604:	f1 e0       	ldi	r31, 0x01	; 1
 606:	80 81       	ld	r24, Z
 608:	10 82       	st	Z, r1
	
	//Startup indicator
	for (int i = 0; i < 2; i++)
 60a:	80 e0       	ldi	r24, 0x00	; 0
 60c:	90 e0       	ldi	r25, 0x00	; 0
 60e:	1a c0       	rjmp	.+52     	; 0x644 <main+0x9a>
	{
		PORTL |= (1<<PL0);
 610:	eb e0       	ldi	r30, 0x0B	; 11
 612:	f1 e0       	ldi	r31, 0x01	; 1
 614:	20 81       	ld	r18, Z
 616:	21 60       	ori	r18, 0x01	; 1
 618:	20 83       	st	Z, r18
 61a:	2f ef       	ldi	r18, 0xFF	; 255
 61c:	35 ea       	ldi	r19, 0xA5	; 165
 61e:	4e e0       	ldi	r20, 0x0E	; 14
 620:	21 50       	subi	r18, 0x01	; 1
 622:	30 40       	sbci	r19, 0x00	; 0
 624:	40 40       	sbci	r20, 0x00	; 0
 626:	e1 f7       	brne	.-8      	; 0x620 <main+0x76>
 628:	00 c0       	rjmp	.+0      	; 0x62a <main+0x80>
 62a:	00 00       	nop
		_delay_ms(300);
		PORTL &= (0<<PL0);
 62c:	20 81       	ld	r18, Z
 62e:	10 82       	st	Z, r1
 630:	ef ef       	ldi	r30, 0xFF	; 255
 632:	f5 ea       	ldi	r31, 0xA5	; 165
 634:	2e e0       	ldi	r18, 0x0E	; 14
 636:	e1 50       	subi	r30, 0x01	; 1
 638:	f0 40       	sbci	r31, 0x00	; 0
 63a:	20 40       	sbci	r18, 0x00	; 0
 63c:	e1 f7       	brne	.-8      	; 0x636 <main+0x8c>
 63e:	00 c0       	rjmp	.+0      	; 0x640 <main+0x96>
 640:	00 00       	nop
	//Beginning sample display indicator
	DDRL |= (1<<DDL0);
	PORTL &= (0<<PL0);
	
	//Startup indicator
	for (int i = 0; i < 2; i++)
 642:	01 96       	adiw	r24, 0x01	; 1
 644:	82 30       	cpi	r24, 0x02	; 2
 646:	91 05       	cpc	r25, r1
 648:	1c f3       	brlt	.-58     	; 0x610 <main+0x66>
		_delay_ms(300);
	}
	
	
	//Button pressed indicator LED (green) will be on Pin 53 on the Arduino Mega
	DDRB |= (1<<DDB0);
 64a:	84 b1       	in	r24, 0x04	; 4
 64c:	81 60       	ori	r24, 0x01	; 1
 64e:	84 b9       	out	0x04, r24	; 4
	PORTB &= (0<<PB0);
 650:	85 b1       	in	r24, 0x05	; 5
 652:	15 b8       	out	0x05, r1	; 5
	
	//Startup indicator
	for (int i = 0; i < 2; i++)
 654:	80 e0       	ldi	r24, 0x00	; 0
 656:	90 e0       	ldi	r25, 0x00	; 0
 658:	18 c0       	rjmp	.+48     	; 0x68a <main+0xe0>
	{
		PORTB |= (1<<PB0);
 65a:	25 b1       	in	r18, 0x05	; 5
 65c:	21 60       	ori	r18, 0x01	; 1
 65e:	25 b9       	out	0x05, r18	; 5
 660:	3f ef       	ldi	r19, 0xFF	; 255
 662:	45 ea       	ldi	r20, 0xA5	; 165
 664:	ee e0       	ldi	r30, 0x0E	; 14
 666:	31 50       	subi	r19, 0x01	; 1
 668:	40 40       	sbci	r20, 0x00	; 0
 66a:	e0 40       	sbci	r30, 0x00	; 0
 66c:	e1 f7       	brne	.-8      	; 0x666 <main+0xbc>
 66e:	00 c0       	rjmp	.+0      	; 0x670 <main+0xc6>
 670:	00 00       	nop
		_delay_ms(300);
		PORTB &= (0<<PB0);
 672:	25 b1       	in	r18, 0x05	; 5
 674:	15 b8       	out	0x05, r1	; 5
 676:	ff ef       	ldi	r31, 0xFF	; 255
 678:	25 ea       	ldi	r18, 0xA5	; 165
 67a:	3e e0       	ldi	r19, 0x0E	; 14
 67c:	f1 50       	subi	r31, 0x01	; 1
 67e:	20 40       	sbci	r18, 0x00	; 0
 680:	30 40       	sbci	r19, 0x00	; 0
 682:	e1 f7       	brne	.-8      	; 0x67c <main+0xd2>
 684:	00 c0       	rjmp	.+0      	; 0x686 <main+0xdc>
 686:	00 00       	nop
	//Button pressed indicator LED (green) will be on Pin 53 on the Arduino Mega
	DDRB |= (1<<DDB0);
	PORTB &= (0<<PB0);
	
	//Startup indicator
	for (int i = 0; i < 2; i++)
 688:	01 96       	adiw	r24, 0x01	; 1
 68a:	82 30       	cpi	r24, 0x02	; 2
 68c:	91 05       	cpc	r25, r1
 68e:	2c f3       	brlt	.-54     	; 0x65a <main+0xb0>
		_delay_ms(300);
	}
	
	
	//Startup indicator LED will be on Pin 11 on the Arduino Mega
	DDRB |= (1<<DDB5);
 690:	84 b1       	in	r24, 0x04	; 4
 692:	80 62       	ori	r24, 0x20	; 32
 694:	84 b9       	out	0x04, r24	; 4
	PORTB &= (0<<PB5);
 696:	85 b1       	in	r24, 0x05	; 5
 698:	15 b8       	out	0x05, r1	; 5
	
	//Startup indicator
	for (int i = 0; i < 3; i++)
 69a:	80 e0       	ldi	r24, 0x00	; 0
 69c:	90 e0       	ldi	r25, 0x00	; 0
 69e:	18 c0       	rjmp	.+48     	; 0x6d0 <main+0x126>
	{
		PORTB |= (1<<PB5);
 6a0:	25 b1       	in	r18, 0x05	; 5
 6a2:	20 62       	ori	r18, 0x20	; 32
 6a4:	25 b9       	out	0x05, r18	; 5
 6a6:	4f ef       	ldi	r20, 0xFF	; 255
 6a8:	e5 ea       	ldi	r30, 0xA5	; 165
 6aa:	fe e0       	ldi	r31, 0x0E	; 14
 6ac:	41 50       	subi	r20, 0x01	; 1
 6ae:	e0 40       	sbci	r30, 0x00	; 0
 6b0:	f0 40       	sbci	r31, 0x00	; 0
 6b2:	e1 f7       	brne	.-8      	; 0x6ac <main+0x102>
 6b4:	00 c0       	rjmp	.+0      	; 0x6b6 <main+0x10c>
 6b6:	00 00       	nop
		_delay_ms(300);
		PORTB &= (0<<PB5);
 6b8:	25 b1       	in	r18, 0x05	; 5
 6ba:	15 b8       	out	0x05, r1	; 5
 6bc:	2f ef       	ldi	r18, 0xFF	; 255
 6be:	35 ea       	ldi	r19, 0xA5	; 165
 6c0:	4e e0       	ldi	r20, 0x0E	; 14
 6c2:	21 50       	subi	r18, 0x01	; 1
 6c4:	30 40       	sbci	r19, 0x00	; 0
 6c6:	40 40       	sbci	r20, 0x00	; 0
 6c8:	e1 f7       	brne	.-8      	; 0x6c2 <main+0x118>
 6ca:	00 c0       	rjmp	.+0      	; 0x6cc <main+0x122>
 6cc:	00 00       	nop
	//Startup indicator LED will be on Pin 11 on the Arduino Mega
	DDRB |= (1<<DDB5);
	PORTB &= (0<<PB5);
	
	//Startup indicator
	for (int i = 0; i < 3; i++)
 6ce:	01 96       	adiw	r24, 0x01	; 1
 6d0:	83 30       	cpi	r24, 0x03	; 3
 6d2:	91 05       	cpc	r25, r1
 6d4:	2c f3       	brlt	.-54     	; 0x6a0 <main+0xf6>
 6d6:	8f ef       	ldi	r24, 0xFF	; 255
 6d8:	93 ed       	ldi	r25, 0xD3	; 211
 6da:	e0 e3       	ldi	r30, 0x30	; 48
 6dc:	81 50       	subi	r24, 0x01	; 1
 6de:	90 40       	sbci	r25, 0x00	; 0
 6e0:	e0 40       	sbci	r30, 0x00	; 0
 6e2:	e1 f7       	brne	.-8      	; 0x6dc <main+0x132>
 6e4:	00 c0       	rjmp	.+0      	; 0x6e6 <main+0x13c>
 6e6:	00 00       	nop
		_delay_ms(300);
	}
	_delay_ms(1000);
	//-------------------------------------------------------------------------------------------------------
	//Low level on INT2, INT3, and INT5 each trigger an interrupt (page 76 of ATmega2560 datasheet)
	EICRA = (0<<ISC31) & (0<<ISC30) & (0<<ISC21) & (0<<ISC20);
 6e8:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7c0069>
	//EICRB = (0<<ISC51) & (0<<ISC50);
	
	//Enable interrupts on INT2 and INT5
	//EIMSK = (1<<INT5) | (1<<INT2);
	EIMSK |= (1<<INT2);
 6ec:	8d b3       	in	r24, 0x1d	; 29
 6ee:	84 60       	ori	r24, 0x04	; 4
 6f0:	8d bb       	out	0x1d, r24	; 29
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Homing sequence
	
	sei();
 6f2:	78 94       	sei
	flag = 0;
 6f4:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <flag+0x1>
 6f8:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <flag>
	while (flag != 1)
 6fc:	11 c0       	rjmp	.+34     	; 0x720 <main+0x176>
	{
		PORTB |= (1<<PB4);
 6fe:	85 b1       	in	r24, 0x05	; 5
 700:	80 61       	ori	r24, 0x10	; 16
 702:	85 b9       	out	0x05, r24	; 5
 704:	87 e8       	ldi	r24, 0x87	; 135
 706:	93 e1       	ldi	r25, 0x13	; 19
 708:	01 97       	sbiw	r24, 0x01	; 1
 70a:	f1 f7       	brne	.-4      	; 0x708 <main+0x15e>
 70c:	00 c0       	rjmp	.+0      	; 0x70e <main+0x164>
 70e:	00 00       	nop
		_delay_ms(1.250);
		PORTB &= (0<<PB4);
 710:	85 b1       	in	r24, 0x05	; 5
 712:	15 b8       	out	0x05, r1	; 5
 714:	e7 e8       	ldi	r30, 0x87	; 135
 716:	f3 e1       	ldi	r31, 0x13	; 19
 718:	31 97       	sbiw	r30, 0x01	; 1
 71a:	f1 f7       	brne	.-4      	; 0x718 <main+0x16e>
 71c:	00 c0       	rjmp	.+0      	; 0x71e <main+0x174>
 71e:	00 00       	nop
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Homing sequence
	
	sei();
	flag = 0;
	while (flag != 1)
 720:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <flag>
 724:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <flag+0x1>
 728:	01 97       	sbiw	r24, 0x01	; 1
 72a:	49 f7       	brne	.-46     	; 0x6fe <main+0x154>
		PORTB |= (1<<PB4);
		_delay_ms(1.250);
		PORTB &= (0<<PB4);
		_delay_ms(1.250);
	}
	cli();
 72c:	f8 94       	cli
	}
	*/
	
	
	//Disable interrupts for homing endstop
	EIMSK &= (0<<INT2);
 72e:	8d b3       	in	r24, 0x1d	; 29
 730:	1d ba       	out	0x1d, r1	; 29
	//Enable interrupts on INT3
	EIMSK |= (1<<INT3);
 732:	8d b3       	in	r24, 0x1d	; 29
 734:	88 60       	ori	r24, 0x08	; 8
 736:	8d bb       	out	0x1d, r24	; 29
	
	
	sei();
 738:	78 94       	sei
	//Wait for CONTINUE button to be pressed
	flag = 0;
 73a:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <flag+0x1>
 73e:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <flag>
	while (flag != 2)
 742:	03 c0       	rjmp	.+6      	; 0x74a <main+0x1a0>
	{
		//Indicator LED
		PORTB |= (1<<PB5);
 744:	85 b1       	in	r24, 0x05	; 5
 746:	80 62       	ori	r24, 0x20	; 32
 748:	85 b9       	out	0x05, r24	; 5
	
	
	sei();
	//Wait for CONTINUE button to be pressed
	flag = 0;
	while (flag != 2)
 74a:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <flag>
 74e:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <flag+0x1>
 752:	02 97       	sbiw	r24, 0x02	; 2
 754:	b9 f7       	brne	.-18     	; 0x744 <main+0x19a>
	{
		//Indicator LED
		PORTB |= (1<<PB5);
	}
	cli();
 756:	f8 94       	cli
	
	//Disable interrupts for CONTINUE button for a brief period
	EIMSK &= (0<<INT3);
 758:	8d b3       	in	r24, 0x1d	; 29
 75a:	1d ba       	out	0x1d, r1	; 29
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Precursor Fiber Stretching
	
	//Invert the direction of the linear drive motor so that the panel mechanism moves backwards
	PORTE &= (0<<PE3);
 75c:	8e b1       	in	r24, 0x0e	; 14
 75e:	1e b8       	out	0x0e, r1	; 14
 760:	ff ef       	ldi	r31, 0xFF	; 255
 762:	29 e6       	ldi	r18, 0x69	; 105
 764:	38 e1       	ldi	r19, 0x18	; 24
 766:	f1 50       	subi	r31, 0x01	; 1
 768:	20 40       	sbci	r18, 0x00	; 0
 76a:	30 40       	sbci	r19, 0x00	; 0
 76c:	e1 f7       	brne	.-8      	; 0x766 <main+0x1bc>
 76e:	00 c0       	rjmp	.+0      	; 0x770 <main+0x1c6>
 770:	00 00       	nop
	
	//Wait a moment before beginning backwards movement so that it doesn't jerk the whole mechanism
	_delay_ms(500);
	
	sei();
 772:	78 94       	sei
	int steps = ((int)(full_rot * ((distance - (offset + exp_offset)) / lead)));
	int thres_slow = steps * 0.75;
	int thres_slowest = steps * 0.95;
	
	//Move backwards the required distance to stretch the precursor fibers to ~0.731 N of tension
	for (int i = 0; i < steps; i++)
 774:	40 e0       	ldi	r20, 0x00	; 0
 776:	50 e0       	ldi	r21, 0x00	; 0
		PORTB &= (0<<PB4);
		_delay_ms(1.250);
	}
	*/
	
	int scaler = 3; //1
 778:	23 e0       	ldi	r18, 0x03	; 3
 77a:	30 e0       	ldi	r19, 0x00	; 0
	int steps = ((int)(full_rot * ((distance - (offset + exp_offset)) / lead)));
	int thres_slow = steps * 0.75;
	int thres_slowest = steps * 0.95;
	
	//Move backwards the required distance to stretch the precursor fibers to ~0.731 N of tension
	for (int i = 0; i < steps; i++)
 77c:	2d c0       	rjmp	.+90     	; 0x7d8 <main+0x22e>
	{
		PORTB |= (1<<PB4);
 77e:	85 b1       	in	r24, 0x05	; 5
 780:	80 61       	ori	r24, 0x10	; 16
 782:	85 b9       	out	0x05, r24	; 5
		for (int j = 0; j < scaler; j++)
 784:	80 e0       	ldi	r24, 0x00	; 0
 786:	90 e0       	ldi	r25, 0x00	; 0
 788:	07 c0       	rjmp	.+14     	; 0x798 <main+0x1ee>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 78a:	ef e1       	ldi	r30, 0x1F	; 31
 78c:	f3 e0       	ldi	r31, 0x03	; 3
 78e:	31 97       	sbiw	r30, 0x01	; 1
 790:	f1 f7       	brne	.-4      	; 0x78e <main+0x1e4>
 792:	00 c0       	rjmp	.+0      	; 0x794 <main+0x1ea>
 794:	00 00       	nop
 796:	01 96       	adiw	r24, 0x01	; 1
 798:	82 17       	cp	r24, r18
 79a:	93 07       	cpc	r25, r19
 79c:	b4 f3       	brlt	.-20     	; 0x78a <main+0x1e0>
		{
			//_delay_ms(1.250);
			_delay_us(200);
		}
		//The only reason I am putting this if statement here and not with the other one is because the comparison between i and thres_slow takes time, just like the comp. between i and thres_slowest. This might make the square wave slightly more even
		if (i >= thres_slow)
 79e:	44 37       	cpi	r20, 0x74	; 116
 7a0:	f2 e5       	ldi	r31, 0x52	; 82
 7a2:	5f 07       	cpc	r21, r31
 7a4:	14 f0       	brlt	.+4      	; 0x7aa <main+0x200>
		{
			scaler = 6;
 7a6:	26 e0       	ldi	r18, 0x06	; 6
 7a8:	30 e0       	ldi	r19, 0x00	; 0
		}
		PORTB &= (0<<PB4);
 7aa:	85 b1       	in	r24, 0x05	; 5
 7ac:	15 b8       	out	0x05, r1	; 5
		for (int j = 0; j < scaler; j++)
 7ae:	80 e0       	ldi	r24, 0x00	; 0
 7b0:	90 e0       	ldi	r25, 0x00	; 0
 7b2:	07 c0       	rjmp	.+14     	; 0x7c2 <main+0x218>
 7b4:	ef e1       	ldi	r30, 0x1F	; 31
 7b6:	f3 e0       	ldi	r31, 0x03	; 3
 7b8:	31 97       	sbiw	r30, 0x01	; 1
 7ba:	f1 f7       	brne	.-4      	; 0x7b8 <main+0x20e>
 7bc:	00 c0       	rjmp	.+0      	; 0x7be <main+0x214>
 7be:	00 00       	nop
 7c0:	01 96       	adiw	r24, 0x01	; 1
 7c2:	82 17       	cp	r24, r18
 7c4:	93 07       	cpc	r25, r19
 7c6:	b4 f3       	brlt	.-20     	; 0x7b4 <main+0x20a>
		{
			//_delay_ms(1.250);
			_delay_us(200);
		}
		if (i >= thres_slowest) //Slows down the stepper as it gets very close to the required distance, just to make sure it doesn't over or undershoot the distance by much
 7c8:	41 37       	cpi	r20, 0x71	; 113
 7ca:	f8 e6       	ldi	r31, 0x68	; 104
 7cc:	5f 07       	cpc	r21, r31
 7ce:	14 f0       	brlt	.+4      	; 0x7d4 <main+0x22a>
		{
			scaler = 44; //7
 7d0:	2c e2       	ldi	r18, 0x2C	; 44
 7d2:	30 e0       	ldi	r19, 0x00	; 0
	int steps = ((int)(full_rot * ((distance - (offset + exp_offset)) / lead)));
	int thres_slow = steps * 0.75;
	int thres_slowest = steps * 0.95;
	
	//Move backwards the required distance to stretch the precursor fibers to ~0.731 N of tension
	for (int i = 0; i < steps; i++)
 7d4:	4f 5f       	subi	r20, 0xFF	; 255
 7d6:	5f 4f       	sbci	r21, 0xFF	; 255
 7d8:	41 3f       	cpi	r20, 0xF1	; 241
 7da:	8d e6       	ldi	r24, 0x6D	; 109
 7dc:	58 07       	cpc	r21, r24
 7de:	7c f2       	brlt	.-98     	; 0x77e <main+0x1d4>
			scaler = 44; //7
		}
	}
	
	
	cli();
 7e0:	f8 94       	cli
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 7e2:	9f ef       	ldi	r25, 0xFF	; 255
 7e4:	e9 e6       	ldi	r30, 0x69	; 105
 7e6:	f8 e1       	ldi	r31, 0x18	; 24
 7e8:	91 50       	subi	r25, 0x01	; 1
 7ea:	e0 40       	sbci	r30, 0x00	; 0
 7ec:	f0 40       	sbci	r31, 0x00	; 0
 7ee:	e1 f7       	brne	.-8      	; 0x7e8 <main+0x23e>
 7f0:	00 c0       	rjmp	.+0      	; 0x7f2 <main+0x248>
 7f2:	00 00       	nop
	
	//Added delay so that one button press doesn't accidentally count as multiple and skip through phases of machine operation
	_delay_ms(500);
	
	//Set the direction of the linear drive so that the panel mechanism moves forwards towards the other panel
	PORTE |= (1<<PE3);
 7f4:	8e b1       	in	r24, 0x0e	; 14
 7f6:	88 60       	ori	r24, 0x08	; 8
 7f8:	8e b9       	out	0x0e, r24	; 14
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Begin Precursor Fiber Twisting
	
	//Enable interrupts on INT3
	EIMSK |= (1<<INT3);
 7fa:	8d b3       	in	r24, 0x1d	; 29
 7fc:	88 60       	ori	r24, 0x08	; 8
 7fe:	8d bb       	out	0x1d, r24	; 29
	
	sei();
 800:	78 94       	sei
	
	//Wait for CONTINUE button to be pressed
	flag = 0;
 802:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <flag+0x1>
 806:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <flag>
	while (flag != 2)
 80a:	03 c0       	rjmp	.+6      	; 0x812 <main+0x268>
	{
		//Indicator LED
		PORTB |= (1<<PB5);
 80c:	85 b1       	in	r24, 0x05	; 5
 80e:	80 62       	ori	r24, 0x20	; 32
 810:	85 b9       	out	0x05, r24	; 5
	
	sei();
	
	//Wait for CONTINUE button to be pressed
	flag = 0;
	while (flag != 2)
 812:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <flag>
 816:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <flag+0x1>
 81a:	02 97       	sbiw	r24, 0x02	; 2
 81c:	b9 f7       	brne	.-18     	; 0x80c <main+0x262>
	{
		//Indicator LED
		PORTB |= (1<<PB5);
	}
	
	cli();
 81e:	f8 94       	cli
	
	PORTB &= (0<<PB5);
 820:	85 b1       	in	r24, 0x05	; 5
 822:	15 b8       	out	0x05, r1	; 5
	
	initTimer0();
 824:	4a dd       	rcall	.-1388   	; 0x2ba <initTimer0>
	
	//Begin Panel Motor movement
	analogWriteV2(128);
 826:	80 e8       	ldi	r24, 0x80	; 128
 828:	90 e0       	ldi	r25, 0x00	; 0
 82a:	8a de       	rcall	.-748    	; 0x540 <analogWriteV2>
 82c:	2f ef       	ldi	r18, 0xFF	; 255
 82e:	39 e6       	ldi	r19, 0x69	; 105
 830:	48 e1       	ldi	r20, 0x18	; 24
 832:	21 50       	subi	r18, 0x01	; 1
 834:	30 40       	sbci	r19, 0x00	; 0
 836:	40 40       	sbci	r20, 0x00	; 0
 838:	e1 f7       	brne	.-8      	; 0x832 <main+0x288>
 83a:	00 c0       	rjmp	.+0      	; 0x83c <main+0x292>
 83c:	00 00       	nop
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Begin Linear Drive Movement (with linear movement speed control)
	
	//Wait until CONTINUE button is pressed again to begin linear drive movement
	flag = 0;
 83e:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <flag+0x1>
 842:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <flag>
	while (flag != 2)
 846:	03 c0       	rjmp	.+6      	; 0x84e <main+0x2a4>
	{
		//Indicator LED
		PORTB |= (1<<PB5);
 848:	85 b1       	in	r24, 0x05	; 5
 84a:	80 62       	ori	r24, 0x20	; 32
 84c:	85 b9       	out	0x05, r24	; 5
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Begin Linear Drive Movement (with linear movement speed control)
	
	//Wait until CONTINUE button is pressed again to begin linear drive movement
	flag = 0;
	while (flag != 2)
 84e:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <flag>
 852:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <flag+0x1>
 856:	02 97       	sbiw	r24, 0x02	; 2
		//Indicator LED
		PORTB |= (1<<PB5);
	}
	
	//Record the first time
	times[0] = millis();
 858:	b9 f7       	brne	.-18     	; 0x848 <main+0x29e>
 85a:	3f dd       	rcall	.-1410   	; 0x2da <millis>
 85c:	60 93 57 1f 	sts	0x1F57, r22	; 0x801f57 <times>
 860:	70 93 58 1f 	sts	0x1F58, r23	; 0x801f58 <times+0x1>
 864:	80 93 59 1f 	sts	0x1F59, r24	; 0x801f59 <times+0x2>
 868:	90 93 5a 1f 	sts	0x1F5A, r25	; 0x801f5a <times+0x3>
	//==============================
	//Implement speed control below
	
	//samplesFlag = 1;
	
	initTimer0();
 86c:	85 b1       	in	r24, 0x05	; 5
 86e:	15 b8       	out	0x05, r1	; 5
	initADC();
 870:	24 dd       	rcall	.-1464   	; 0x2ba <initTimer0>
 872:	4b dd       	rcall	.-1386   	; 0x30a <initADC>
	
	//Indicator LED
	PORTB |= (1<<PB5);
 874:	85 b1       	in	r24, 0x05	; 5
 876:	80 62       	ori	r24, 0x20	; 32
 878:	85 b9       	out	0x05, r24	; 5
	
	//Begin linear drive movement and speed control loop
	flag = 0;
 87a:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <flag+0x1>
 87e:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <flag>
	while (flag != 2)
 882:	29 c0       	rjmp	.+82     	; 0x8d6 <main+0x32c>
	{
		PORTB |= (1<<PB4);
 884:	85 b1       	in	r24, 0x05	; 5
 886:	80 61       	ori	r24, 0x10	; 16
 888:	85 b9       	out	0x05, r24	; 5
		for (uint16_t i = 0; i < (sampVal + 70); i++)
 88a:	20 e0       	ldi	r18, 0x00	; 0
 88c:	30 e0       	ldi	r19, 0x00	; 0
 88e:	06 c0       	rjmp	.+12     	; 0x89c <main+0x2f2>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 890:	85 e3       	ldi	r24, 0x35	; 53
 892:	8a 95       	dec	r24
 894:	f1 f7       	brne	.-4      	; 0x892 <main+0x2e8>
 896:	00 00       	nop
 898:	2f 5f       	subi	r18, 0xFF	; 255
 89a:	3f 4f       	sbci	r19, 0xFF	; 255
 89c:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 8a0:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 8a4:	8a 5b       	subi	r24, 0xBA	; 186
 8a6:	9f 4f       	sbci	r25, 0xFF	; 255
 8a8:	28 17       	cp	r18, r24
 8aa:	39 07       	cpc	r19, r25
 8ac:	88 f3       	brcs	.-30     	; 0x890 <main+0x2e6>
		{
			_delay_us(10);
		}
		PORTB &= (0<<PB4);
 8ae:	85 b1       	in	r24, 0x05	; 5
 8b0:	15 b8       	out	0x05, r1	; 5
		for (uint16_t i = 0; i < (sampVal + 70); i++)
 8b2:	20 e0       	ldi	r18, 0x00	; 0
 8b4:	30 e0       	ldi	r19, 0x00	; 0
 8b6:	06 c0       	rjmp	.+12     	; 0x8c4 <main+0x31a>
 8b8:	95 e3       	ldi	r25, 0x35	; 53
 8ba:	9a 95       	dec	r25
 8bc:	f1 f7       	brne	.-4      	; 0x8ba <main+0x310>
 8be:	00 00       	nop
 8c0:	2f 5f       	subi	r18, 0xFF	; 255
 8c2:	3f 4f       	sbci	r19, 0xFF	; 255
 8c4:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 8c8:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
 8cc:	8a 5b       	subi	r24, 0xBA	; 186
 8ce:	9f 4f       	sbci	r25, 0xFF	; 255
 8d0:	28 17       	cp	r18, r24
 8d2:	39 07       	cpc	r19, r25
 8d4:	88 f3       	brcs	.-30     	; 0x8b8 <main+0x30e>
	//Indicator LED
	PORTB |= (1<<PB5);
	
	//Begin linear drive movement and speed control loop
	flag = 0;
	while (flag != 2)
 8d6:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <flag>
 8da:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <flag+0x1>
		{
			_delay_us(10);
		}
	}
	
	PORTB &= (0<<PB5);
 8de:	02 97       	sbiw	r24, 0x02	; 2
 8e0:	89 f6       	brne	.-94     	; 0x884 <main+0x2da>
	//==============================
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Stop all movement
	
	stopADC();
 8e2:	85 b1       	in	r24, 0x05	; 5
 8e4:	15 b8       	out	0x05, r1	; 5
	
	//Record the second time
	times[1] = millis();
 8e6:	3f dd       	rcall	.-1410   	; 0x366 <stopADC>
 8e8:	f8 dc       	rcall	.-1552   	; 0x2da <millis>
 8ea:	60 93 5b 1f 	sts	0x1F5B, r22	; 0x801f5b <times+0x4>
 8ee:	70 93 5c 1f 	sts	0x1F5C, r23	; 0x801f5c <times+0x5>
 8f2:	80 93 5d 1f 	sts	0x1F5D, r24	; 0x801f5d <times+0x6>
 8f6:	90 93 5e 1f 	sts	0x1F5E, r25	; 0x801f5e <times+0x7>
	
	//Stop panel movement, linear drive movement is already stopped
	analogWriteV2(0);
 8fa:	80 e0       	ldi	r24, 0x00	; 0
 8fc:	90 e0       	ldi	r25, 0x00	; 0
 8fe:	20 de       	rcall	.-960    	; 0x540 <analogWriteV2>
	
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	//Indicator
	for (int i = 0; i < 5; i++)
 900:	20 e0       	ldi	r18, 0x00	; 0
 902:	30 e0       	ldi	r19, 0x00	; 0
 904:	19 c0       	rjmp	.+50     	; 0x938 <main+0x38e>
	{
		PORTB |= (1<<PB0);
 906:	85 b1       	in	r24, 0x05	; 5
 908:	81 60       	ori	r24, 0x01	; 1
 90a:	85 b9       	out	0x05, r24	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 90c:	ef ef       	ldi	r30, 0xFF	; 255
 90e:	f5 ea       	ldi	r31, 0xA5	; 165
 910:	4e e0       	ldi	r20, 0x0E	; 14
 912:	e1 50       	subi	r30, 0x01	; 1
 914:	f0 40       	sbci	r31, 0x00	; 0
 916:	40 40       	sbci	r20, 0x00	; 0
 918:	e1 f7       	brne	.-8      	; 0x912 <main+0x368>
 91a:	00 c0       	rjmp	.+0      	; 0x91c <main+0x372>
 91c:	00 00       	nop
		_delay_ms(300);
		PORTB &= (0<<PB0);
 91e:	85 b1       	in	r24, 0x05	; 5
 920:	15 b8       	out	0x05, r1	; 5
 922:	8f ef       	ldi	r24, 0xFF	; 255
 924:	95 ea       	ldi	r25, 0xA5	; 165
 926:	ee e0       	ldi	r30, 0x0E	; 14
 928:	81 50       	subi	r24, 0x01	; 1
 92a:	90 40       	sbci	r25, 0x00	; 0
 92c:	e0 40       	sbci	r30, 0x00	; 0
 92e:	e1 f7       	brne	.-8      	; 0x928 <main+0x37e>
 930:	00 c0       	rjmp	.+0      	; 0x932 <main+0x388>
 932:	00 00       	nop
	//Stop panel movement, linear drive movement is already stopped
	analogWriteV2(0);
	
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	//Indicator
	for (int i = 0; i < 5; i++)
 934:	2f 5f       	subi	r18, 0xFF	; 255
 936:	3f 4f       	sbci	r19, 0xFF	; 255
 938:	25 30       	cpi	r18, 0x05	; 5
 93a:	31 05       	cpc	r19, r1
 93c:	24 f3       	brlt	.-56     	; 0x906 <main+0x35c>
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Display recorded data
	
	//Wait for Continue button press before first time is displayed
	sei();
 93e:	78 94       	sei
	flag = 0;
 940:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <flag+0x1>
 944:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <flag>
	while (flag != 2)
 948:	03 c0       	rjmp	.+6      	; 0x950 <main+0x3a6>
	{
		PORTB |= (1<<PB5);
 94a:	85 b1       	in	r24, 0x05	; 5
 94c:	80 62       	ori	r24, 0x20	; 32
 94e:	85 b9       	out	0x05, r24	; 5
	//Display recorded data
	
	//Wait for Continue button press before first time is displayed
	sei();
	flag = 0;
	while (flag != 2)
 950:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <flag>
 954:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <flag+0x1>
 958:	02 97       	sbiw	r24, 0x02	; 2
 95a:	b9 f7       	brne	.-18     	; 0x94a <main+0x3a0>
	{
		PORTB |= (1<<PB5);
	}
	cli();
 95c:	f8 94       	cli
	
	displayTime(times[0]);
 95e:	60 91 57 1f 	lds	r22, 0x1F57	; 0x801f57 <times>
 962:	70 91 58 1f 	lds	r23, 0x1F58	; 0x801f58 <times+0x1>
 966:	80 91 59 1f 	lds	r24, 0x1F59	; 0x801f59 <times+0x2>
 96a:	90 91 5a 1f 	lds	r25, 0x1F5A	; 0x801f5a <times+0x3>
 96e:	e5 dd       	rcall	.-1078   	; 0x53a <displayTime>
	
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	//Indicator
	for (int i = 0; i < 5; i++)
 970:	20 e0       	ldi	r18, 0x00	; 0
 972:	30 e0       	ldi	r19, 0x00	; 0
 974:	19 c0       	rjmp	.+50     	; 0x9a8 <main+0x3fe>
	{
		PORTB |= (1<<PB5);
 976:	85 b1       	in	r24, 0x05	; 5
 978:	80 62       	ori	r24, 0x20	; 32
 97a:	85 b9       	out	0x05, r24	; 5
 97c:	ff ef       	ldi	r31, 0xFF	; 255
 97e:	49 e6       	ldi	r20, 0x69	; 105
 980:	88 e1       	ldi	r24, 0x18	; 24
 982:	f1 50       	subi	r31, 0x01	; 1
 984:	40 40       	sbci	r20, 0x00	; 0
 986:	80 40       	sbci	r24, 0x00	; 0
 988:	e1 f7       	brne	.-8      	; 0x982 <main+0x3d8>
 98a:	00 c0       	rjmp	.+0      	; 0x98c <main+0x3e2>
 98c:	00 00       	nop
		_delay_ms(500);
		PORTB &= (0<<PB5);
 98e:	85 b1       	in	r24, 0x05	; 5
 990:	15 b8       	out	0x05, r1	; 5
 992:	9f ef       	ldi	r25, 0xFF	; 255
 994:	e9 e6       	ldi	r30, 0x69	; 105
 996:	f8 e1       	ldi	r31, 0x18	; 24
 998:	91 50       	subi	r25, 0x01	; 1
 99a:	e0 40       	sbci	r30, 0x00	; 0
 99c:	f0 40       	sbci	r31, 0x00	; 0
 99e:	e1 f7       	brne	.-8      	; 0x998 <main+0x3ee>
 9a0:	00 c0       	rjmp	.+0      	; 0x9a2 <main+0x3f8>
 9a2:	00 00       	nop
	
	displayTime(times[0]);
	
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	//Indicator
	for (int i = 0; i < 5; i++)
 9a4:	2f 5f       	subi	r18, 0xFF	; 255
 9a6:	3f 4f       	sbci	r19, 0xFF	; 255
 9a8:	25 30       	cpi	r18, 0x05	; 5
 9aa:	31 05       	cpc	r19, r1
 9ac:	24 f3       	brlt	.-56     	; 0x976 <main+0x3cc>
		_delay_ms(500);
	}
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	
	//Wait for Continue button press before second time is displayed
	sei();
 9ae:	78 94       	sei
	flag = 0;
 9b0:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <flag+0x1>
 9b4:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <flag>
	while (flag != 2)
 9b8:	03 c0       	rjmp	.+6      	; 0x9c0 <main+0x416>
	{
		PORTB |= (1<<PB5);
 9ba:	85 b1       	in	r24, 0x05	; 5
 9bc:	80 62       	ori	r24, 0x20	; 32
 9be:	85 b9       	out	0x05, r24	; 5
	//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	
	//Wait for Continue button press before second time is displayed
	sei();
	flag = 0;
	while (flag != 2)
 9c0:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <flag>
 9c4:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <flag+0x1>
 9c8:	02 97       	sbiw	r24, 0x02	; 2
 9ca:	b9 f7       	brne	.-18     	; 0x9ba <main+0x410>
	{
		PORTB |= (1<<PB5);
	}
	cli();
	
	displayTime(times[1]);
 9cc:	f8 94       	cli
 9ce:	60 91 5b 1f 	lds	r22, 0x1F5B	; 0x801f5b <times+0x4>
 9d2:	70 91 5c 1f 	lds	r23, 0x1F5C	; 0x801f5c <times+0x5>
 9d6:	80 91 5d 1f 	lds	r24, 0x1F5D	; 0x801f5d <times+0x6>
 9da:	90 91 5e 1f 	lds	r25, 0x1F5E	; 0x801f5e <times+0x7>
 9de:	ad dd       	rcall	.-1190   	; 0x53a <displayTime>
	
	//Wait for Continue button press before potentiometer samples are displayed
	sei();
 9e0:	78 94       	sei
	flag = 0;
 9e2:	10 92 05 02 	sts	0x0205, r1	; 0x800205 <flag+0x1>
 9e6:	10 92 04 02 	sts	0x0204, r1	; 0x800204 <flag>
	while (flag != 2)
 9ea:	03 c0       	rjmp	.+6      	; 0x9f2 <main+0x448>
	{
		PORTB |= (1<<PB5);
 9ec:	85 b1       	in	r24, 0x05	; 5
 9ee:	80 62       	ori	r24, 0x20	; 32
	displayTime(times[1]);
	
	//Wait for Continue button press before potentiometer samples are displayed
	sei();
	flag = 0;
	while (flag != 2)
 9f0:	85 b9       	out	0x05, r24	; 5
 9f2:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <flag>
 9f6:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <flag+0x1>
 9fa:	02 97       	sbiw	r24, 0x02	; 2
	{
		PORTB |= (1<<PB5);
	}
	cli();
 9fc:	b9 f7       	brne	.-18     	; 0x9ec <main+0x442>
	
	displayPotSamples();
 9fe:	f8 94       	cli
 a00:	64 dd       	rcall	.-1336   	; 0x4ca <displayPotSamples>
 a02:	80 e0       	ldi	r24, 0x00	; 0
 a04:	90 e0       	ldi	r25, 0x00	; 0
 a06:	08 95       	ret

00000a08 <__udivmodsi4>:
 a08:	a1 e2       	ldi	r26, 0x21	; 33
 a0a:	1a 2e       	mov	r1, r26
 a0c:	aa 1b       	sub	r26, r26
 a0e:	bb 1b       	sub	r27, r27
 a10:	fd 01       	movw	r30, r26
 a12:	0d c0       	rjmp	.+26     	; 0xa2e <__udivmodsi4_ep>

00000a14 <__udivmodsi4_loop>:
 a14:	aa 1f       	adc	r26, r26
 a16:	bb 1f       	adc	r27, r27
 a18:	ee 1f       	adc	r30, r30
 a1a:	ff 1f       	adc	r31, r31
 a1c:	a2 17       	cp	r26, r18
 a1e:	b3 07       	cpc	r27, r19
 a20:	e4 07       	cpc	r30, r20
 a22:	f5 07       	cpc	r31, r21
 a24:	20 f0       	brcs	.+8      	; 0xa2e <__udivmodsi4_ep>
 a26:	a2 1b       	sub	r26, r18
 a28:	b3 0b       	sbc	r27, r19
 a2a:	e4 0b       	sbc	r30, r20
 a2c:	f5 0b       	sbc	r31, r21

00000a2e <__udivmodsi4_ep>:
 a2e:	66 1f       	adc	r22, r22
 a30:	77 1f       	adc	r23, r23
 a32:	88 1f       	adc	r24, r24
 a34:	99 1f       	adc	r25, r25
 a36:	1a 94       	dec	r1
 a38:	69 f7       	brne	.-38     	; 0xa14 <__udivmodsi4_loop>
 a3a:	60 95       	com	r22
 a3c:	70 95       	com	r23
 a3e:	80 95       	com	r24
 a40:	90 95       	com	r25
 a42:	9b 01       	movw	r18, r22
 a44:	ac 01       	movw	r20, r24
 a46:	bd 01       	movw	r22, r26
 a48:	cf 01       	movw	r24, r30
 a4a:	08 95       	ret

00000a4c <_exit>:
 a4c:	f8 94       	cli

00000a4e <__stop_program>:
 a4e:	ff cf       	rjmp	.-2      	; 0xa4e <__stop_program>
